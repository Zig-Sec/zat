//! A Query of the [EUVD database](https://euvd.enisa.europa.eu/apidoc).

const std = @import("std");

pub const endpoint = "https://euvdservices.enisa.europa.eu/api/search";

const Query = @This();

product: ?[]const u8 = null,
page: ?usize = null,
size: ?usize = null,

pub fn new() @This() {
    return .{};
}

pub fn setProduct(self: @This(), product: []const u8) @This() {
    var s = self;
    s.product = product;
    return s;
}

pub fn setPage(self: @This(), page: usize) @This() {
    var s = self;
    s.page = page;
    return s;
}

pub fn setSize(self: @This(), size: usize) @This() {
    var s = self;
    s.size = size;
    return s;
}

pub fn fetch(self: @This(), allocator: std.mem.Allocator) !Result {
    var client: std.http.Client = .{
        .allocator = allocator,
    };
    defer client.deinit();

    const qs = try self.allocQueryString(allocator);
    defer allocator.free(qs);

    var response = std.Io.Writer.Allocating.init(allocator);
    defer response.deinit();

    _ = try client.fetch(.{
        .method = .GET,
        .location = .{ .url = qs },
        .response_writer = &response.writer,
    });

    const result = try std.json.parseFromSliceLeaky(
        Result,
        allocator,
        response.written(),
        .{
            .ignore_unknown_fields = true,
            .allocate = .alloc_always,
        },
    );

    return result;
}

pub fn allocQueryString(self: @This(), allocator: std.mem.Allocator) ![]const u8 {
    var str = std.Io.Writer.Allocating.init(allocator);
    errdefer str.deinit();

    var count: usize = 0;

    try str.writer.print("{s}", .{endpoint});

    if (self.product) |product| {
        if (count == 0) try str.writer.writeByte('?');
        if (count > 0) try str.writer.writeByte('&');

        try str.writer.print("product={s}", .{product});
        count += 1;
    }

    if (self.page) |page| {
        if (count == 0) try str.writer.writeByte('?');
        if (count > 0) try str.writer.writeByte('&');

        try str.writer.print("page={d}", .{page});
        count += 1;
    }

    if (self.size) |size| {
        if (count == 0) try str.writer.writeByte('?');
        if (count > 0) try str.writer.writeByte('&');

        try str.writer.print("size={d}", .{size});
        count += 1;
    }

    return try str.toOwnedSlice();
}

pub const Result = struct {
    items: []const Advisory,
    total: usize,

    /// A EUVD Advisory
    pub const Advisory = struct {
        /// A EUVD Identifier in the fromat EUVD-YYYY-NNNNN.
        id: []const u8,
        /// A description of the vulnerability.
        description: []const u8,
        /// The date the advisory was published.
        datePublished: []const u8,
        /// The date the advisory was last updated.
        dateUpdated: []const u8,
        /// The CVSS base score.
        baseScore: f32,
        /// The CVSS version used for scoring.
        baseScoreVersion: []const u8,
        /// The CVSS vector.
        baseScoreVector: []const u8,
        /// A string containing references related to the given advisory (separated by
        /// new-lines '\n').
        references: []const u8,
        /// Aliases of this advisory, e.g. a CVE ID (separated by new-lines '\n').
        aliases: []const u8,
        assigner: []const u8,
        epss: f32,
        /// The product names and affected versions. Each affected version is represented
        /// by a dedicated entry.
        enisaIdProduct: []const EnisaIdProduct,
        enisaIdVendor: []const EnisaIdVendor,

        pub const EnisaIdProduct = struct {
            id: []const u8,
            product: struct {
                /// The product name.
                name: []const u8,
            },
            /// The version of the product affected (e.g. "1.1.1 <1.1.1w").
            product_version: []const u8,

            pub fn deinit(self: *const @This(), allocator: std.mem.Allocator) void {
                allocator.free(self.id);
                allocator.free(self.product.name);
                allocator.free(self.product_version);
            }
        };

        pub const EnisaIdVendor = struct {
            id: []const u8,
            vendor: struct {
                name: []const u8,
            },

            pub fn deinit(self: *const @This(), allocator: std.mem.Allocator) void {
                allocator.free(self.id);
                allocator.free(self.vendor.name);
            }
        };

        pub fn deinit(self: *const @This(), allocator: std.mem.Allocator) void {
            allocator.free(self.id);
            allocator.free(self.description);
            allocator.free(self.datePublished);
            allocator.free(self.dateUpdated);
            allocator.free(self.baseScoreVersion);
            allocator.free(self.baseScoreVector);
            allocator.free(self.references);
            allocator.free(self.aliases);
            allocator.free(self.assigner);
            for (self.enisaIdProduct) |product| product.deinit(allocator);
            allocator.free(self.enisaIdProduct);
            for (self.enisaIdVendor) |vendor| vendor.deinit(allocator);
            allocator.free(self.enisaIdVendor);
        }
    };

    pub fn deinit(self: *const @This(), allocator: std.mem.Allocator) void {
        for (self.items) |advisory| advisory.deinit(allocator);
        allocator.free(self.items);
    }
};

test "create query string #1" {
    const allocator = std.testing.allocator;

    const q = Query.new().setProduct("openssl");
    const s = try q.allocQueryString(allocator);
    defer allocator.free(s);

    try std.testing.expectEqualStrings("https://euvdservices.enisa.europa.eu/api/search?product=openssl", s);
}

test "create query string #2" {
    const allocator = std.testing.allocator;

    const q = Query.new().setProduct("openssl").setPage(2);
    const s = try q.allocQueryString(allocator);
    defer allocator.free(s);

    try std.testing.expectEqualStrings("https://euvdservices.enisa.europa.eu/api/search?product=openssl&page=2", s);
}

test "json to Zig #1" {
    const allocator = std.testing.allocator;
    const result_str =
        \\{
        \\"items": [
        \\  {
        \\    "id": "EUVD-2023-54651",
        \\    "description": "Issue summary: The POLY1305 MAC (message authentication code) implementation\ncontains a bug that might corrupt the internal state of applications on the\nWindows 64 platform when running on newer X86_64 processors supporting the\nAVX512-IFMA instructions.\n\nImpact summary: If in an application that uses the OpenSSL library an attacker\ncan influence whether the POLY1305 MAC algorithm is used, the application\nstate might be corrupted with various application dependent consequences.\n\nThe POLY1305 MAC (message authentication code) implementation in OpenSSL does\nnot save the contents of non-volatile XMM registers on Windows 64 platform\nwhen calculating the MAC of data larger than 64 bytes. Before returning to\nthe caller all the XMM registers are set to zero rather than restoring their\nprevious content. The vulnerable code is used only on newer x86_64 processors\nsupporting the AVX512-IFMA instructions.\n\nThe consequences of this kind of internal application state corruption can\nbe various - from no consequences, if the calling application does not\ndepend on the contents of non-volatile XMM registers at all, to the worst\nconsequences, where the attacker could get complete control of the application\nprocess. However given the contents of the registers are just zeroized so\nthe attacker cannot put arbitrary values inside, the most likely consequence,\nif any, would be an incorrect result of some application dependent\ncalculations or a crash leading to a denial of service.\n\nThe POLY1305 MAC algorithm is most frequently used as part of the\nCHACHA20-POLY1305 AEAD (authenticated encryption with associated data)\nalgorithm. The most common usage of this AEAD cipher is with TLS protocol\nversions 1.2 and 1.3 and a malicious client can influence whether this AEAD\ncipher is used by the server. This implies that server applications using\nOpenSSL can be potentially impacted. However we are currently not aware of\nany concrete application that would be affected by this issue therefore we\nconsider this a Low severity security issue.\n\nAs a workaround the AVX512-IFMA instructions support can be disabled at\nruntime by setting the environment variable OPENSSL_ia32cap:\n\n   OPENSSL_ia32cap=:~0x200000\n\nThe FIPS provider is not affected by this issue.",
        \\    "datePublished": "Sep 8, 2023, 11:01:53 AM",
        \\    "dateUpdated": "Aug 27, 2025, 8:42:52 PM",
        \\    "baseScore": 7.8,
        \\    "baseScoreVersion": "3.1",
        \\    "baseScoreVector": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H",
        \\    "references": "https://www.openssl.org/news/secadv/20230908.txt\nhttps://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=4bfac4471f53c4f74c8d81020beb938f92d84ca5\nhttps://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=6754de4a121ec7f261b16723180df6592cbb4508\nhttps://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=a632d534c73eeb3e3db8c7540d811194ef7c79ff\nhttps://security.netapp.com/advisory/ntap-20230921-0001/\n",
        \\    "aliases": "CVE-2023-4807\nGSD-2023-4807\n",
        \\    "assigner": "openssl",
        \\    "epss": 0.66,
        \\    "enisaIdProduct": [
        \\      {
        \\        "id": "598c6846-3a53-3d0d-a77d-6ec4aa554134",
        \\        "product": {
        \\          "name": "OpenSSL"
        \\        },
        \\        "product_version": "1.1.1 <1.1.1w"
        \\      },
        \\      {
        \\        "id": "afcabd52-6f3a-3989-813b-40aa875e8bb5",
        \\        "product": {
        \\          "name": "OpenSSL"
        \\        },
        \\        "product_version": "3.0.0 <3.0.11"
        \\      },
        \\      {
        \\        "id": "dc246dfb-e32c-3c0a-bdf4-99b2f90e7aea",
        \\        "product": {
        \\          "name": "OpenSSL"
        \\        },
        \\        "product_version": "3.1.0 <3.1.3"
        \\      }
        \\    ],
        \\    "enisaIdVendor": [
        \\      {
        \\        "id": "83e26f70-2209-35b4-9b89-7f991af1ba56",
        \\        "vendor": {
        \\          "name": "OpenSSL"
        \\        }
        \\      }
        \\    ]
        \\  },
        \\  {
        \\    "id": "EUVD-2023-0817",
        \\    "description": "There is a type confusion vulnerability relating to X.400 address processing\ninside an X.509 GeneralName. X.400 addresses were parsed as an ASN1_STRING but\nthe public structure definition for GENERAL_NAME incorrectly specified the type\nof the x400Address field as ASN1_TYPE. This field is subsequently interpreted by\nthe OpenSSL function GENERAL_NAME_cmp as an ASN1_TYPE rather than an\nASN1_STRING.\n\nWhen CRL checking is enabled (i.e. the application sets the\nX509_V_FLAG_CRL_CHECK flag), this vulnerability may allow an attacker to pass\narbitrary pointers to a memcmp call, enabling them to read memory contents or\nenact a denial of service. In most cases, the attack requires the attacker to\nprovide both the certificate chain and CRL, neither of which need to have a\nvalid signature. If the attacker only controls one of these inputs, the other\ninput must already contain an X.400 address as a CRL distribution point, which\nis uncommon. As such, this vulnerability is most likely to only affect\napplications which have implemented their own functionality for retrieving CRLs\nover a network.",
        \\    "datePublished": "Feb 8, 2023, 7:01:50 PM",
        \\    "dateUpdated": "Aug 27, 2025, 8:32:52 PM",
        \\    "baseScore": 7.4,
        \\    "baseScoreVersion": "3.1",
        \\    "baseScoreVector": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:N/A:H",
        \\    "references": "https://github.com/pyca/cryptography/security/advisories/GHSA-x4qr-2fvf-3mr5\nhttps://nvd.nist.gov/vuln/detail/CVE-2023-0286\nhttps://access.redhat.com/security/cve/cve-2023-0286\nhttps://ftp.openbsd.org/pub/OpenBSD/LibreSSL/libressl-3.6.2-relnotes.txt\nhttps://ftp.openbsd.org/pub/OpenBSD/patches/7.2/common/018_x509.patch.sig\nhttps://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=2c6c9d439b484e1ba9830d8454a34fa4f80fdfe9\nhttps://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=2f7530077e0ef79d98718138716bc51ca0cad658\nhttps://git.openssl.org/gitweb/?p=openssl.git;a=commitdiff;h=fd2af07dc083a350c959147097003a14a5e8ac4d\nhttps://github.com/pyca/cryptography\nhttps://rustsec.org/advisories/RUSTSEC-2023-0006.html\nhttps://security.gentoo.org/glsa/202402-08\nhttps://www.openssl.org/news/secadv/20230207.txt\nhttps://alas.aws.amazon.com/cve/html/CVE-2023-0286.html\nhttps://www.debian.org/security/2023/dsa-5343\nhttps://access.redhat.com/errata/RHSA-2023:0946\nhttps://www.suse.com/security/cve/CVE-2023-0286.html\nhttps://ubuntu.com/security/CVE-2023-0286\n",
        \\    "aliases": "CVE-2023-0286\nGHSA-x4qr-2fvf-3mr5\n",
        \\    "assigner": "openssl",
        \\    "epss": 88.1,
        \\    "enisaIdProduct": [
        \\      {
        \\        "id": "2ba08550-bb10-3d30-a1bf-1a57c2895d26",
        \\        "product": {
        \\          "name": "OpenSSL"
        \\        },
        \\        "product_version": "1.0.2 <1.0.2zg"
        \\      },
        \\      {
        \\        "id": "4e238dbb-d14e-3bf5-9049-9c28b8764415",
        \\        "product": {
        \\          "name": "OpenSSL"
        \\        },
        \\        "product_version": "1.1.1 <1.1.1t"
        \\      },
        \\      {
        \\        "id": "dc0f84e1-d341-34d4-8610-92db0c244dcf",
        \\        "product": {
        \\          "name": "OpenSSL"
        \\        },
        \\        "product_version": "3.0.0 <3.0.8"
        \\      }
        \\    ],
        \\    "enisaIdVendor": [
        \\      {
        \\        "id": "4f91236d-405b-3a5a-8b26-58cbdf34cd7e",
        \\        "vendor": {
        \\          "name": "OpenSSL"
        \\        }
        \\      }
        \\    ]
        \\  }
        \\  ],
        \\  "total": 92
        \\}
    ;

    const result = try std.json.parseFromSlice(
        Result,
        allocator,
        result_str,
        .{
            .ignore_unknown_fields = true,
        },
    );
    defer result.deinit();

    try std.testing.expectEqualStrings("EUVD-2023-54651", result.value.items[0].id);

    try std.testing.expectEqualStrings("EUVD-2023-0817", result.value.items[1].id);
    try std.testing.expectEqualStrings("OpenSSL", result.value.items[1].enisaIdProduct[0].product.name);
    try std.testing.expectEqualStrings("1.0.2 <1.0.2zg", result.value.items[1].enisaIdProduct[0].product_version);
}

test "query database #1" {
    const allocator = std.testing.allocator;

    const q = Query.new().setProduct("openssl").setSize(1);

    var result = try q.fetch(allocator);
    defer result.deinit(allocator);

    try std.testing.expectEqual(@as(usize, 1), result.items.len);
}
