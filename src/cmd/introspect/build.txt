// This build function is meant be be injected into a build.zig together
// with injected.zig. The infjected.zig file contains the wrapper used
// to obtain information from the build system.
//
// Steps:
// 1. duplicate build.zig as fallback
// 2. rename build to build2 replacing the argument type with zat.Build
// 3. inject the function as seen below
// 4. inject the code from injected.zig
// 5. run `build zig -h` and observe the output. By displaying the help we prevent
//    build zig from initiating the build process (just the build graph is generated).
//    The line starting with "Usage" marks the start of the help output.
//    Everything else obove is for us.
pub fn build(b: *std_zat_.Build) !void {
    var b_ = zat.Build.new(b);

    buil_(&b_);

    var comps = std_zat_.ArrayList(zat.Components.Component).init(b.allocator);

    for (b_.compiles.items) |comp| {
        try comps.append(try zat.Components.Component.fromCompile(b.allocator, comp));
    }

    var module_iterator = b.modules.iterator();
    while (module_iterator.next()) |kv| {
        try comps.append(try zat.Components.Component.fromModule(
            kv.key_ptr.*,
            b.allocator,
            kv.value_ptr.*,
        ));
    }

    const components = zat.Components{
        .components = try comps.toOwnedSlice(),
    };

    const comp_json = try std_zat_.json.stringifyAlloc(b.allocator, components, .{
        .whitespace = .indent_2,
        .emit_null_optional_fields = false,
    });

    try std_zat_.io.getStdOut().writeAll(comp_json);
    try std_zat_.io.getStdOut().writeAll("\n");
}
